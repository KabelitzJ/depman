#!/usr/bin/env python3
import argparse
import os
import sys
import subprocess
import hashlib
from datetime import datetime, timezone
from pathlib import Path
import yaml  # pip install pyyaml


DEF_LOCK = "dependency.lock.yaml"


# ----------------- utilities -----------------

def run(cmd, cwd=None, check=True):
  proc = subprocess.run(
    cmd,
    cwd=cwd,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True
  )
  if check and proc.returncode != 0:
    raise RuntimeError(
      f"Command failed ({proc.returncode}): {' '.join(cmd)}\n{proc.stderr}"
    )
  return proc.stdout.strip()


def now_iso():
  return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def sha256_file(path: Path) -> str:
  h = hashlib.sha256()
  with path.open("rb") as f:
    for chunk in iter(lambda: f.read(1 << 20), b""):
      h.update(chunk)
  return f"sha256:{h.hexdigest()}"


def load_config(file: Path) -> dict:
  if not file.exists():
    sys.exit(f"Config file not found: {file}")

  if file.suffix.lower() not in (".yaml", ".yml"):
    sys.exit("Config must be YAML (.yaml/.yml)")

  data = yaml.safe_load(file.read_text())

  if not isinstance(data, dict) or "dependencies" not in data or not isinstance(data["dependencies"], list):
    sys.exit("Config must be a mapping with a 'dependencies' list")

  for d in data["dependencies"]:
    for key in ("name", "path", "url"):
      if key not in d:
        sys.exit(f"Dependency missing '{key}': {d}")
    if sum(k in d for k in ("tag", "branch", "rev")) > 1:
      sys.exit(f"Use exactly one of tag/branch/rev for {d['name']}")
    d.setdefault("shallow", True)
    d.setdefault("flags", {})

  return data


def load_lock(lock_path: Path) -> dict:
  if lock_path.exists():
    return yaml.safe_load(lock_path.read_text()) or {}
  return {
    "lock_version": 1,
    "generated_at": now_iso(),
    "source_file": None,
    "source_digest": None,
    "dependencies": []
  }


def write_lock(lock_path: Path, lock_obj: dict):
  lock_obj["lock_version"] = 1
  lock_obj["generated_at"] = now_iso()
  text = yaml.safe_dump(lock_obj, sort_keys=False)
  lock_path.write_text(text)
  print(f"Updated lock: {lock_path}")

def is_bool_like(v) -> bool:
  s = str(v).strip().upper()
  return s in ("ON", "OFF", "TRUE", "FALSE", "0", "1")

def write_dependencies_cmake(cfg: dict, out_path: Path):
  lines = [
    "# This file is auto-generated by depman. Do not edit by hand.",
    "include_guard(GLOBAL)",
    ""
  ]

  for dep in cfg["dependencies"]:
    name = dep.get("name", "").strip() or "(unnamed)"
    url = dep.get("url", "")
    path = (dep.get("path", "") or "").replace("\\", "/")
    tag = dep.get("tag")
    branch = dep.get("branch")
    rev = dep.get("rev")

    # ---- block header
    lines.append(f"# ---- {name}")
    if url:
      lines.append(f"# url: {url}")
    lines.append(f"# path: {path}")
    if tag:
      lines.append(f"# tag: {tag}")
    elif branch:
      lines.append(f"# branch: {branch}")
    elif rev:
      lines.append(f"# rev: {rev}")
    else:
      lines.append("# version: (unspecified)")

    lines.append("")

    # ---- flags
    flags = dep.get("flags", {}) or {}
    if flags:
      for k, v in flags.items():
        cache_type = "BOOL" if is_bool_like(v) else "STRING"
        lines.append(f'set({k} {v} CACHE {cache_type} "" FORCE)')
    else:
      lines.append("# (no flags)")

    lines.append("")

    # ---- add_subdirectory
    lines.append("add_subdirectory(${CMAKE_SOURCE_DIR}/" + path + ")")
    lines.append("")  # blank line between dependencies

  out_path.write_text("\n".join(lines) + "\n")
  print(f"Wrote CMake dependencies file: {out_path}")

def version_label_from_dep(dep: dict) -> str:
  """Return a human-friendly version label from a dep declaration."""
  if dep.get("tag"):
    return f"tag {dep['tag']}"
  if dep.get("branch"):
    return f"branch {dep['branch']}"
  if dep.get("rev"):
    r = str(dep["rev"])
    return f"rev {r[:12]}"
  return "unspecified"

def short_rev(rev: str | None) -> str:
  return (rev or "")[:12] if rev else "None"

def map_lock_entries(lock: dict) -> dict[tuple[str, str], dict]:
  """Map (name, path) -> lock entry."""
  return {
    (d.get("name"), d.get("path")): d
    for d in (lock.get("dependencies") or [])
    if isinstance(d, dict)
  }

def map_cfg_deps(cfg: dict) -> dict[tuple[str, str], dict]:
  """Map (name, path) -> dep config entry."""
  return {
    (d.get("name"), d.get("path")): d
    for d in (cfg.get("dependencies") or [])
    if isinstance(d, dict)
  }

def ensure_repo_root():
  try:
    top = run(["git", "rev-parse", "--show-toplevel"])
  except Exception:
    sys.exit("Not a git repository (or no git in PATH). Init repo first.")
  os.chdir(top)


def git_submodule_exists(path: str) -> bool:
  gm = Path(".gitmodules")
  return gm.exists() and f"path = {path}" in gm.read_text()


def git_current_rev(path: str) -> str | None:
  if not Path(path).exists():
    return None
  try:
    return run(["git", "-C", path, "rev-parse", "HEAD"])
  except Exception:
    return None


def is_git_ignored(path: str) -> bool:
  try:
    res = subprocess.run(
      ["git", "check-ignore", "-q", path],
      stdout=subprocess.DEVNULL,
      stderr=subprocess.DEVNULL
    )
    return res.returncode == 0
  except Exception:
    return False


def git_add_submodule(url: str, path: str, shallow: bool):
  args = ["git", "submodule", "add"]
  if shallow:
    args += ["--depth", "1"]
  args += [url, path]

  try:
    run(args)
  except RuntimeError as e:
    msg = str(e)
    if "ignored by one of your .gitignore files" in msg or is_git_ignored(path):
      print(f"   warning: '{path}' is ignored by .gitignore; retrying with -f")
      run(["git", "submodule", "add", "-f"] + args[3:])
      return
    raise


def git_set_version(path: str, tag=None, branch=None, rev=None, shallow=True):
  fetch_args = ["git", "-C", path, "fetch", "--tags", "--prune"]
  if shallow:
    fetch_args += ["--depth", "1"]
  run(fetch_args)

  if tag:
    run(["git", "-C", path, "checkout", "-f", f"tags/{tag}"])
  elif branch:
    run(["git", "-C", path, "checkout", "-f", branch])
  elif rev:
    run(["git", "-C", path, "checkout", "-f", rev])
  else:
    for b in ("main", "master"):
      try:
        run(["git", "-C", path, "checkout", "-f", b])
        break
      except RuntimeError:
        continue

  rev_exact = run(["git", "-C", path, "rev-parse", "HEAD"])
  run(["git", "-C", path, "checkout", "-f", rev_exact])
  run(["git", "add", path])
  return rev_exact


def find_in_lock(lock: dict, name: str, path: str):
  for d in lock.get("dependencies", []):
    if d.get("name") == name and d.get("path") == path:
      return d
  return None


def update_lock_entry(lock: dict, dep: dict, rev: str):
  entry = find_in_lock(lock, dep["name"], dep["path"])
  payload = {
    "name": dep["name"],
    "path": dep["path"],
    "url": dep["url"],
    "pinned": {"rev": rev}
  }
  if entry:
    entry.update(payload)
  else:
    lock.setdefault("dependencies", []).append(payload)


# ----------------- commands -----------------

def cmd_sync(args):
  ensure_repo_root()

  deps_path = Path(args.deps_file)
  cfg = load_config(deps_path)

  # Keep a snapshot of the previous lock state for diffing later
  lock_path = Path(args.lock)
  prev_lock = load_lock(lock_path)
  prev_map = map_lock_entries(prev_lock)

  lock = load_lock(lock_path)
  lock["source_file"] = os.path.relpath(str(deps_path))
  lock["source_digest"] = sha256_file(deps_path)

  # Apply current config (add/update submodules)
  for dep in cfg["dependencies"]:
    print(f"==> {dep['name']} @ {dep['path']}")
    if not git_submodule_exists(dep["path"]):
      print("   adding submodule…")
      git_add_submodule(dep["url"], dep["path"], dep["shallow"])
    print("   setting version…")
    rev = git_set_version(
      dep["path"],
      tag=dep.get("tag"),
      branch=dep.get("branch"),
      rev=dep.get("rev"),
      shallow=dep.get("shallow", True)
    )
    print(f"   pinned to {rev[:12]}")
    update_lock_entry(lock, dep, rev)

  # Remove lock entries that are no longer in the config (so we can detect "removed")
  cfg_keys = set(map_cfg_deps(cfg).keys())
  lock["dependencies"] = [
    d for d in (lock.get("dependencies") or [])
    if (d.get("name"), d.get("path")) in cfg_keys
  ]

  print("")

  # Write artifacts
  write_lock(lock_path, lock)
  deps_cmake = Path("dependencies/dependencies.cmake")
  deps_cmake.parent.mkdir(parents=True, exist_ok=True)
  write_dependencies_cmake(cfg, deps_cmake)

  # ---- Change summary
  new_map = map_lock_entries(lock)
  added = sorted(set(new_map.keys()) - set(prev_map.keys()))
  removed = sorted(set(prev_map.keys()) - set(new_map.keys()))
  common = sorted(set(new_map.keys()) & set(prev_map.keys()))

  # Updated = rev changed
  updated = []
  for key in common:
    old_rev = (prev_map[key].get("pinned") or {}).get("rev")
    new_rev = (new_map[key].get("pinned") or {}).get("rev")
    if old_rev and new_rev and old_rev != new_rev:
      updated.append(key)

  if added or removed or updated:
    print("\nDependency changes:")
    cfg_map = map_cfg_deps(cfg)

    for key in added:
      dep = cfg_map[key]
      print(f"  ADDED    {dep['name']}: {version_label_from_dep(dep)} -> {short_rev((new_map[key].get('pinned') or {}).get('rev'))}")

    for key in updated:
      dep = cfg_map[key]
      old_rev = (prev_map[key].get("pinned") or {}).get("rev")
      new_rev = (new_map[key].get("pinned") or {}).get("rev")
      print(f"  UPDATED  {dep['name']}: {version_label_from_dep(dep)}  {short_rev(old_rev)} -> {short_rev(new_rev)}")

    for key in removed:
      old = prev_map[key]
      print(f"  REMOVED  {old.get('name')}: was {short_rev((old.get('pinned') or {}).get('rev'))}")
  else:
    print("\nNo dependency changes detected.")


def cmd_status(args):
  ensure_repo_root()

  deps_path = Path(args.deps_file)
  cfg = load_config(deps_path)
  lock = load_lock(Path(args.lock))

  digest = sha256_file(deps_path)
  if lock.get("source_digest") != digest:
    print("Config changed since last lock.")

  for dep in cfg["dependencies"]:
    cur = git_current_rev(dep["path"])
    le = find_in_lock(lock, dep["name"], dep["path"])
    locked = (le or {}).get("pinned", {}).get("rev")

    if not cur:
      status = "MISSING"
    elif locked and cur != locked:
      status = f"DRIFT (cur {cur[:12]} ≠ lock {locked[:12]})"
    else:
      status = "OK"

    print(f"{dep['name']:<16} {dep['path']:<32} {status}")


def cmd_lock(args):
  ensure_repo_root()

  deps_path = Path(args.deps_file)
  cfg = load_config(deps_path)

  # Snapshot previous lock for diff
  lock_path = Path(args.lock)
  prev_lock = load_lock(lock_path)
  prev_map = map_lock_entries(prev_lock)

  lock = load_lock(lock_path)
  lock["source_file"] = os.path.relpath(str(deps_path))
  lock["source_digest"] = sha256_file(deps_path)

  # Refresh lock from current working tree
  for dep in cfg["dependencies"]:
    cur = git_current_rev(dep["path"])
    if cur:
      update_lock_entry(lock, dep, cur)

  # Prune removed deps
  cfg_keys = set(map_cfg_deps(cfg).keys())
  lock["dependencies"] = [
    d for d in (lock.get("dependencies") or [])
    if (d.get("name"), d.get("path")) in cfg_keys
  ]

  write_lock(lock_path, lock)

  deps_cmake = Path("dependencies/dependencies.cmake")
  deps_cmake.parent.mkdir(parents=True, exist_ok=True)
  write_dependencies_cmake(cfg, deps_cmake)

  # ---- Change summary
  new_map = map_lock_entries(lock)
  added = sorted(set(new_map.keys()) - set(prev_map.keys()))
  removed = sorted(set(prev_map.keys()) - set(new_map.keys()))
  common = sorted(set(new_map.keys()) & set(prev_map.keys()))

  updated = []
  for key in common:
    old_rev = (prev_map[key].get("pinned") or {}).get("rev")
    new_rev = (new_map[key].get("pinned") or {}).get("rev")
    if old_rev and new_rev and old_rev != new_rev:
      updated.append(key)

  if added or removed or updated:
    print("\nDependency changes:")
    cfg_map = map_cfg_deps(cfg)

    for key in added:
      dep = cfg_map.get(key, {"name": key[0]})
      print(f"  ADDED    {dep['name']}: {version_label_from_dep(dep)} -> {short_rev((new_map[key].get('pinned') or {}).get('rev'))}")

    for key in updated:
      dep = cfg_map.get(key, {"name": key[0]})
      old_rev = (prev_map[key].get("pinned") or {}).get("rev")
      new_rev = (new_map[key].get("pinned") or {}).get("rev")
      print(f"  UPDATED  {dep['name']}: {version_label_from_dep(dep)}  {short_rev(old_rev)} -> {short_rev(new_rev)}")

    for key in removed:
      old = prev_map[key]
      print(f"  REMOVED  {old.get('name')}: was {short_rev((old.get('pinned') or {}).get('rev'))}")
  else:
    print("\nNo dependency changes detected.")



# ----------------- main -----------------

def main():
  ap = argparse.ArgumentParser("depman - yaml-only git submodule manager")
  ap.add_argument(
    "-l", "--lock",
    default=DEF_LOCK,
    help="lock file path (YAML)"
  )

  sp = ap.add_subparsers(dest="cmd")

  sp_sync = sp.add_parser("sync", help="add/update submodules and write lock")
  sp_sync.add_argument("deps_file", help="path to dependency.yaml|yml")
  sp_sync.set_defaults(func=cmd_sync)

  sp_status = sp.add_parser("status", help="show drift vs lock")
  sp_status.add_argument("deps_file", help="path to dependency.yaml|yml")
  sp_status.set_defaults(func=cmd_status)

  sp_lock = sp.add_parser("lock", help="regenerate lockfile from current submodules")
  sp_lock.add_argument("deps_file", help="path to dependency.yaml|yml")
  sp_lock.set_defaults(func=cmd_lock)

  args = ap.parse_args()
  if not args.cmd:
    ap.print_help()
    sys.exit(0)

  args.func(args)


if __name__ == "__main__":
  main()
