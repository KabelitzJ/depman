#!/usr/bin/env python3
import argparse
import os
import sys
import subprocess
import hashlib
from datetime import datetime, timezone
from pathlib import Path
import yaml  # pip install pyyaml


# ----------------- utilities -----------------

def run(cmd, cwd=None, check=True):
  proc = subprocess.run(
    cmd,
    cwd=cwd,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True
  )
  if check and proc.returncode != 0:
    raise RuntimeError(
      f"Command failed ({proc.returncode}): {' '.join(cmd)}\n{proc.stderr}"
    )
  return proc.stdout.strip()


def now_iso():
  return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def sha256_file(path: Path) -> str:
  h = hashlib.sha256()
  with path.open("rb") as f:
    for chunk in iter(lambda: f.read(1 << 20), b""):
      h.update(chunk)
  return f"sha256:{h.hexdigest()}"


def load_config(file: Path) -> dict:
  if not file.exists():
    sys.exit(f"Config file not found: {file}")

  if file.suffix.lower() not in (".yaml", ".yml"):
    sys.exit("Config must be YAML (.yaml/.yml)")

  data = yaml.safe_load(file.read_text())

  if not isinstance(data, dict) or "dependencies" not in data or not isinstance(data["dependencies"], list):
    sys.exit("Config must be a mapping with a 'dependencies' list")

  # Top-level base path is optional; default 'dependencies'
  if "path" in data and not isinstance(data["path"], str):
    sys.exit("Top-level 'path' must be a string if present")

  for d in data["dependencies"]:
    for key in ("name", "url"):
      if key not in d:
        sys.exit(f"Dependency missing '{key}': {d}")
    if sum(k in d for k in ("tag", "branch", "rev")) > 1:
      sys.exit(f"Use exactly one of tag/branch/rev for {d['name']}")
    d.setdefault("shallow", True)
    d.setdefault("flags", {})

  return data


def load_lock(lock_path: Path) -> dict:
  if lock_path.exists():
    return yaml.safe_load(lock_path.read_text()) or {}
  return {
    "lock_version": 1,
    "generated_at": now_iso(),
    "source_file": None,
    "source_digest": None,
    "dependencies": []
  }


def write_lock(lock_path: Path, lock_obj: dict):
  lock_obj["lock_version"] = 1
  lock_obj["generated_at"] = now_iso()
  lock_path.parent.mkdir(parents=True, exist_ok=True)
  text = yaml.safe_dump(lock_obj, sort_keys=False)
  lock_path.write_text(text)
  print(f"Updated lock: {lock_path}")


def is_bool_like(v) -> bool:
  s = str(v).strip().upper()
  return s in ("ON", "OFF", "TRUE", "FALSE", "0", "1")


def get_repo_root() -> Path:
  top = Path(run(["git", "rev-parse", "--show-toplevel"]))
  return top


def ensure_repo_root() -> Path:
  try:
    top = get_repo_root()
  except Exception:
    sys.exit("Not a git repository (or no git in PATH). Init repo first.")
  os.chdir(top)
  return top


def get_base_path(cfg: dict) -> str:
  base = (cfg.get("path") or "dependencies").strip().rstrip("/\\")
  return base if base else "dependencies"


def resolve_paths(cfg: dict, deps_yaml_path: Path, repo_root: Path):
  """
  Returns:
    base_abs: absolute Path for base dir (relative to deps_yaml_dir)
    base_rel_from_repo: base dir relative to repo root (for output files)
    dep_rel_paths: dict name -> relpath (from repo root) for each submodule
  """
  base_rel_from_yaml = get_base_path(cfg)
  base_abs = (deps_yaml_path.parent / base_rel_from_yaml).resolve()
  base_rel_from_repo = Path(os.path.relpath(base_abs, repo_root)).as_posix()

  dep_rel_paths = {}
  for dep in cfg["dependencies"]:
    name = dep["name"]
    sub_abs = (base_abs / name).resolve()
    sub_rel_repo = os.path.relpath(sub_abs, repo_root)
    dep_rel_paths[name] = Path(sub_rel_repo).as_posix()

  return base_abs, base_rel_from_repo, dep_rel_paths


def write_dependencies_cmake(cfg: dict, out_path: Path, dep_rel_paths: dict[str, str]):
  lines = [
    "# This file is auto-generated by depman. Do not edit by hand.",
    "include_guard(GLOBAL)",
    ""
  ]

  for dep in cfg["dependencies"]:
    name = dep.get("name", "").strip() or "(unnamed)"
    url = dep.get("url", "")
    tag = dep.get("tag")
    branch = dep.get("branch")
    rev = dep.get("rev")
    full_rel = dep_rel_paths[name]

    # ---- block header
    lines.append(f"# ---- {name}")
    if url:
      lines.append(f"# url: {url}")
    lines.append(f"# path: {full_rel}")
    if tag:
      lines.append(f"# tag: {tag}")
    elif branch:
      lines.append(f"# branch: {branch}")
    elif rev:
      lines.append(f"# rev: {rev}")
    else:
      lines.append("# version: (unspecified)")
    lines.append("")

    # ---- flags
    flags = dep.get("flags", {}) or {}
    if flags:
      for k, v in flags.items():
        cache_type = "BOOL" if is_bool_like(v) else "STRING"
        lines.append(f'set({k} {v} CACHE {cache_type} "" FORCE)')
    else:
      lines.append("# (no flags)")
    lines.append("")

    # ---- add_subdirectory
    lines.append(f"add_subdirectory(${{CMAKE_SOURCE_DIR}}/{full_rel})")
    lines.append("")

  out_path.parent.mkdir(parents=True, exist_ok=True)
  out_path.write_text("\n".join(lines) + "\n")
  print(f"Wrote CMake dependencies file: {out_path}")


def git_submodule_exists(path: str) -> bool:
  gm = Path(".gitmodules")
  return gm.exists() and f"path = {path}" in gm.read_text()


def git_current_rev(path: str) -> str | None:
  if not Path(path).exists():
    return None
  try:
    return run(["git", "-C", path, "rev-parse", "HEAD"])
  except Exception:
    return None


def is_git_ignored(path: str) -> bool:
  try:
    res = subprocess.run(
      ["git", "check-ignore", "-q", path],
      stdout=subprocess.DEVNULL,
      stderr=subprocess.DEVNULL
    )
    return res.returncode == 0
  except Exception:
    return False


def git_add_submodule(url: str, path: str, shallow: bool):
  args = ["git", "submodule", "add"]
  if shallow:
    args += ["--depth", "1"]
  args += [url, path]

  try:
    run(args)
  except RuntimeError as e:
    msg = str(e)
    if "ignored by one of your .gitignore files" in msg or is_git_ignored(path):
      print(f"   warning: '{path}' is ignored by .gitignore; retrying with -f")
      run(["git", "submodule", "add", "-f"] + args[3:])
      return
    raise


def git_set_version(path: str, tag=None, branch=None, rev=None, shallow=True):
  fetch_args = ["git", "-C", path, "fetch", "--tags", "--prune"]
  if shallow:
    fetch_args += ["--depth", "1"]
  run(fetch_args)

  if tag:
    run(["git", "-C", path, "checkout", "-f", f"tags/{tag}"])
  elif branch:
    run(["git", "-C", path, "checkout", "-f", branch])
  elif rev:
    run(["git", "-C", path, "checkout", "-f", rev])
  else:
    for b in ("main", "master"):
      try:
        run(["git", "-C", path, "checkout", "-f", b])
        break
      except RuntimeError:
        continue

  rev_exact = run(["git", "-C", path, "rev-parse", "HEAD"])
  run(["git", "-C", path, "checkout", "-f", rev_exact])
  run(["git", "add", path])
  return rev_exact


def find_in_lock(lock: dict, name: str, path: str):
  for d in lock.get("dependencies", []):
    if d.get("name") == name and d.get("path") == path:
      return d
  return None


def update_lock_entry(lock: dict, dep_for_lock: dict, rev: str):
  name = dep_for_lock["name"]
  path = dep_for_lock["path"]
  entry = find_in_lock(lock, name, path)
  payload = {
    "name": name,
    "path": path,
    "url": dep_for_lock["url"],
    "pinned": {"rev": rev}
  }
  if entry:
    entry.update(payload)
  else:
    lock.setdefault("dependencies", []).append(payload)


def version_label_from_dep(dep: dict) -> str:
  if dep.get("tag"):
    return f"tag {dep['tag']}"
  if dep.get("branch"):
    return f"branch {dep['branch']}"
  if dep.get("rev"):
    r = str(dep["rev"])
    return f"rev {r[:12]}"
  return "unspecified"

def short_rev(rev: str | None) -> str:
  return (rev or "")[:12] if rev else "None"

def map_lock_entries(lock: dict) -> dict[tuple[str, str], dict]:
  return {
    (d.get("name"), d.get("path")): d
    for d in (lock.get("dependencies") or [])
    if isinstance(d, dict)
  }

def map_cfg_deps_with_paths(cfg: dict, dep_rel_paths: dict[str, str]) -> dict[tuple[str, str], dict]:
  out = {}
  for dep in (cfg.get("dependencies") or []):
    name = dep.get("name")
    if not name:
      continue
    path = dep_rel_paths.get(name)
    if path:
      out[(name, path)] = dep
  return out


# ----------------- commands -----------------

def cmd_sync(args):
  repo_root = ensure_repo_root()

  deps_path = Path(args.deps_file).resolve()
  cfg = load_config(deps_path)

  # resolve paths relative to YAML file
  base_abs, base_rel_from_repo, dep_rel_paths = resolve_paths(cfg, deps_path, repo_root)

  # lock file location: CLI -l wins; else <base>/dependencies.lock.yaml
  lock_path = Path(args.lock).resolve() if args.lock else (base_abs / "dependencies.lock.yaml")
  prev_lock = load_lock(lock_path)
  prev_map = map_lock_entries(prev_lock)

  lock = load_lock(lock_path)
  lock["source_file"] = os.path.relpath(str(deps_path), repo_root)
  lock["source_digest"] = sha256_file(deps_path)

  # add/update
  for dep in cfg["dependencies"]:
    name = dep["name"]
    full_rel = dep_rel_paths[name]
    print(f"==> {name} @ {full_rel}")
    if not git_submodule_exists(full_rel):
      print("   adding submodule…")
      git_add_submodule(dep["url"], full_rel, dep["shallow"])
    print("   setting version…")
    rev = git_set_version(
      full_rel,
      tag=dep.get("tag"),
      branch=dep.get("branch"),
      rev=dep.get("rev"),
      shallow=dep.get("shallow", True)
    )
    print(f"   pinned to {rev[:12]}")
    dep_for_lock = dict(dep)
    dep_for_lock["path"] = full_rel
    update_lock_entry(lock, dep_for_lock, rev)

  # prune removed
  cfg_map = map_cfg_deps_with_paths(cfg, dep_rel_paths)
  cfg_keys = set(cfg_map.keys())
  lock["dependencies"] = [
    d for d in (lock.get("dependencies") or [])
    if (d.get("name"), d.get("path")) in cfg_keys
  ]

  write_lock(lock_path, lock)

  deps_cmake = Path(base_abs / "dependencies.cmake")
  write_dependencies_cmake(cfg, deps_cmake, dep_rel_paths)

  # summary
  new_map = map_lock_entries(lock)
  added = sorted(set(new_map.keys()) - set(prev_map.keys()))
  removed = sorted(set(prev_map.keys()) - set(new_map.keys()))
  common = sorted(set(new_map.keys()) & set(prev_map.keys()))

  updated = []
  for key in common:
    old_rev = (prev_map[key].get("pinned") or {}).get("rev")
    new_rev = (new_map[key].get("pinned") or {}).get("rev")
    if old_rev and new_rev and old_rev != new_rev:
      updated.append(key)

  if added or removed or updated:
    print("\nDependency changes:")
    for key in added:
      dep = cfg_map[key]
      print(f"  ADDED    {dep['name']}: {version_label_from_dep(dep)} -> {short_rev((new_map[key].get('pinned') or {}).get('rev'))}")
    for key in updated:
      dep = cfg_map[key]
      old_rev = (prev_map[key].get("pinned") or {}).get("rev")
      new_rev = (new_map[key].get("pinned") or {}).get("rev")
      print(f"  UPDATED  {dep['name']}: {version_label_from_dep(dep)}  {short_rev(old_rev)} -> {short_rev(new_rev)}")
    for key in removed:
      old = prev_map[key]
      print(f"  REMOVED  {old.get('name')}: was {short_rev((old.get('pinned') or {}).get('rev'))}")
  else:
    print("\nNo dependency changes detected.")


def cmd_status(args):
  repo_root = ensure_repo_root()

  deps_path = Path(args.deps_file).resolve()
  cfg = load_config(deps_path)

  base_abs, base_rel_from_repo, dep_rel_paths = resolve_paths(cfg, deps_path, repo_root)
  lock_path = Path(args.lock).resolve() if args.lock else (base_abs / "dependencies.lock.yaml")
  lock = load_lock(lock_path)

  digest = sha256_file(deps_path)
  if lock.get("source_digest") != digest:
    print("Config changed since last lock.")

  for dep in cfg["dependencies"]:
    name = dep["name"]
    full_rel = dep_rel_paths[name]
    cur = git_current_rev(full_rel)
    le = find_in_lock(lock, name, full_rel)
    locked = (le or {}).get("pinned", {}).get("rev")

    if not cur:
      status = "MISSING"
    elif locked and cur != locked:
      status = f"DRIFT (cur {cur[:12]} ≠ lock {locked[:12]})"
    else:
      status = "OK"

    print(f"{name:<16} {full_rel:<40} {status}")


def cmd_lock(args):
  repo_root = ensure_repo_root()

  deps_path = Path(args.deps_file).resolve()
  cfg = load_config(deps_path)

  base_abs, base_rel_from_repo, dep_rel_paths = resolve_paths(cfg, deps_path, repo_root)
  lock_path = Path(args.lock).resolve() if args.lock else (base_abs / "dependencies.lock.yaml")

  prev_lock = load_lock(lock_path)
  prev_map = map_lock_entries(prev_lock)

  lock = load_lock(lock_path)
  lock["source_file"] = os.path.relpath(str(deps_path), repo_root)
  lock["source_digest"] = sha256_file(deps_path)

  for dep in cfg["dependencies"]:
    name = dep["name"]
    full_rel = dep_rel_paths[name]
    cur = git_current_rev(full_rel)
    if cur:
      dep_for_lock = dict(dep)
      dep_for_lock["path"] = full_rel
      update_lock_entry(lock, dep_for_lock, cur)

  # prune removed
  cfg_map = map_cfg_deps_with_paths(cfg, dep_rel_paths)
  cfg_keys = set(cfg_map.keys())
  lock["dependencies"] = [
    d for d in (lock.get("dependencies") or [])
    if (d.get("name"), d.get("path")) in cfg_keys
  ]

  write_lock(lock_path, lock)

  deps_cmake = Path(base_abs / "dependencies.cmake")
  write_dependencies_cmake(cfg, deps_cmake, dep_rel_paths)

  # summary
  new_map = map_lock_entries(lock)
  added = sorted(set(new_map.keys()) - set(prev_map.keys()))
  removed = sorted(set(prev_map.keys()) - set(new_map.keys()))
  common = sorted(set(new_map.keys()) & set(prev_map.keys()))

  updated = []
  for key in common:
    old_rev = (prev_map[key].get("pinned") or {}).get("rev")
    new_rev = (new_map[key].get("pinned") or {}).get("rev")
    if old_rev and new_rev and old_rev != new_rev:
      updated.append(key)

  if added or removed or updated:
    print("\nDependency changes:")
    for key in added:
      dep = cfg_map.get(key, {"name": key[0]})
      print(f"  ADDED    {dep['name']}: {version_label_from_dep(dep)} -> {short_rev((new_map[key].get('pinned') or {}).get('rev'))}")
    for key in updated:
      dep = cfg_map.get(key, {"name": key[0]})
      old_rev = (prev_map[key].get("pinned") or {}).get("rev")
      new_rev = (new_map[key].get("pinned") or {}).get("rev")
      print(f"  UPDATED  {dep['name']}: {version_label_from_dep(dep)}  {short_rev(old_rev)} -> {short_rev(new_rev)}")
    for key in removed:
      old = prev_map[key]
      print(f"  REMOVED  {old.get('name')}: was {short_rev((old.get('pinned') or {}).get('rev'))}")
  else:
    print("\nNo dependency changes detected.")


# ----------------- main -----------------

def main():
  ap = argparse.ArgumentParser("depman - yaml-only git submodule manager")
  ap.add_argument(
    "-l", "--lock",
    default=None,
    help="lock file path (YAML); defaults to <path>/dependencies.lock.yaml from the YAML"
  )

  sp = ap.add_subparsers(dest="cmd")

  sp_sync = sp.add_parser("sync", help="add/update submodules and write lock")
  sp_sync.add_argument("deps_file", help="path to dependency.yaml|yml")
  sp_sync.set_defaults(func=cmd_sync)

  sp_status = sp.add_parser("status", help="show drift vs lock")
  sp_status.add_argument("deps_file", help="path to dependency.yaml|yml")
  sp_status.set_defaults(func=cmd_status)

  sp_lock = sp.add_parser("lock", help="regenerate lockfile from current submodules")
  sp_lock.add_argument("deps_file", help="path to dependency.yaml|yml")
  sp_lock.set_defaults(func=cmd_lock)

  args = ap.parse_args()
  if not args.cmd:
    ap.print_help()
    sys.exit(0)

  args.func(args)


if __name__ == "__main__":
  main()
